// Multithreading 

Need to start working on Part 2, get more clarification on what the deliverables are for this 
project. It is due next week so should try to get done by friday. 

Multithreading has more than one function that is running in parrallell. 

Need to use locking mechanisms to ensure threads do not violate shared memory contraints. 

// Implementation of threads in Java 
can implement a thread as a callable interface so that when it completes a task it returns a value

public class ThreadA extends Thread{
private String name;
public ThreadA(String name)
{
this.name=name;
}
public void run()
{
 System.out.println("hello from :" + name);
}
}

A thread class automatically becomes a thread. A runnable interface needs to be created into a thread 
example below 

import java.lang.Runnable;
public class ThreadB implements Runnable{
private String name;
public ThreadB(String name)
{
this.name=name;
}
public void run()
{
 System.out.println("hello from :" + name);
}
}

// Thread Pool  

Can exucute a large number of threads in parrallell 

create all the threads, then create a dispatcher that can execute a number of threads at a given time 

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class SimpleThreadPool {
 public static void main(String[] args) {
 ExecutorService executor = Executors.newFixedThreadPool(5);
 for (int i = 0; i < 10; i++) {
 String name = "B " + i;
 Runnable worker = new ThreadB(name);
 executor.execute(worker);
 }
 executor.shutdown();
 while (!executor.isTerminated()) {
 }
 System.out.println("Finished all threads");
 }
}
